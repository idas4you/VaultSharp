using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using VaultSharp.V1.Commons;

namespace VaultSharp.V1.SecretsEngines.SSH
{
    public class SSHRoles
    {
        /// <summary>
        /// Specifies the name of the registered key in Vault. Before creating the role, use the keys/ endpoint to create a named key. This is required for "Dynamic Key" type
        /// </summary>
        [JsonProperty("key")]
        public string Key { get; set; }
        /// <summary>
        /// Specifies the admin user at remote host. The shared key being registered should be for this user and should have root or sudo privileges. Every time a dynamic credential is generated for a client, Vault uses this admin username to login to remote host and install the generated credential. This is required for Dynamic Key type.

        /// </summary>
        [JsonProperty("admin_user")]
        public string AdminUser { get; set; }
        /// <summary>
        ///  Specifies the default username for which a credential will be generated. When the endpoint creds/ is used without a username, this value will be used as default username. Its recommended to create individual roles for each username to ensure absolute isolation between usernames. This is required for Dynamic Key type and OTP type.
        /// When default_user_template is set to true, this field can contain an identity template with any prefix or suffix, like ssh-{{identity.entity.id}}-user.
        /// For the CA type, if you wish this to be a valid principal, it must also be in allowed_users.
        /// </summary>
        [JsonProperty("default_user")]
        public string DefaultUser { get; set; }
        /// <summary>
        /// If set, default_users can be specified using identity template values. A non-templated user is also permitted.
        /// </summary>
        [JsonProperty("default_user_template")]
        public bool DefaultUserTemplate { get; set; } = false;
        /// <summary>
        /// Specifies a comma separated list of CIDR blocks for which the role is applicable for. It is possible that a same set of CIDR blocks are part of multiple roles. This is a required parameter, unless the role is registered under the /config/zeroaddress endpoint. Note: [Not applicable for CA type]
        /// </summary>
        [JsonProperty("cidr_list")]
        public string CidrList { get; set; }
        /// <summary>
        /// Specifies a comma-separated list of CIDR blocks. IP addresses belonging to these blocks are not accepted by the role. This is particularly useful when big CIDR blocks are being used by the role and certain parts need to be kept out. Note: [Not applicable for CA type
        /// </summary>
        [JsonProperty("exclude_cidr_list")]
        public string ExcludeCidrList { get; set; }
        /// <summary>
        /// Specifies the port number for SSH connection. Port number does not play any role in OTP generation. For the otp secrets engine type, this is just a way to inform the client about the port number to use. The port number will be returned to the client by Vault along with the OTP.
        /// </summary>
        [JsonProperty("port")]
        public int Port { get; set; } = 22; 
        /// <summary>
        /// Specifies the type of credentials generated by this role. This can be either otp, dynamic or ca.
        /// </summary>
        [JsonProperty("key_type")]
        public string KeyType { get; set; }
        /// <summary>
        /// Specifies the length of the RSA dynamic key in bits. This can be either 1024 or 2048.
        /// </summary>
        [JsonProperty("key_bits")]
        public int KeyBits { get; set; } = 1024;
        /// <summary>
        /// Specifies the script used to install and uninstall public keys in the target machine. Defaults to the built-in script.
        /// </summary>
        [JsonProperty("install_script")]
        public string InstallScript { get; set; }
        /// <summary>
        /// If this option is not specified, or if it is *, the client can request a credential for any valid user at the remote host, including the admin user. To only allow an explicit list of users, set this parameter using a comma-separated username list to enforce it. When this parameter is set, the credentials are created only for default_user and usernames listed. Setting this option will enable all the users with access this role to fetch credentials for all other usernames in this list. When allowed_users_template is set to true, this field can contain an identity template with any prefix or suffix, like ssh-{{identity.entity.id}}-user. Use with caution. N.B.: if the type is ca, an empty list does not allow any user; instead you must use * to enable this behavior.
        /// </summary>
        [JsonProperty("allowed_users")]
        public string AllowedUsers { get; set; }
        /// <summary>
        /// If set, allowed_users can be specified using identity template policies. Non-templated users are also permitted.
        /// </summary>
        [JsonProperty("allowed_users_template")]
        public bool AllowedUsersTemplate { get; set; } = false;
        /// <summary>
        /// A comma-separated list of domains for which a client can request a host certificate. If this option is explicitly set to "*", then credentials can be created for any domain. See also allow_bare_domains and allow_subdomains.
        /// </summary>
        [JsonProperty("allowed_domains")]
        public string AllowedDomains { get; set; }
        /// <summary>
        /// If set, allowed_domains can be specified using identity template policies. Non-templated domains are also permitted.
        /// </summary>
        [JsonProperty("allowed_domains_template")]
        public bool AllowedDomainsTemplate { get; set; } = false;
        /// <summary>
        /// Specifies a comma separated option specification which will be prefixed to RSA keys in the remote host's authorized_keys file. N.B.: Vault does not check this string for validity.
        /// </summary>
        [JsonProperty("key_option_specs")]
        public string KeyOptionSpecs { get; set; }
        /// <summary>
        /// Specifies the Time To Live value provided as a string duration with time suffix. Hour is the largest suffix. If not set, uses the system default value or the value of max_ttl, whichever is shorter.
        /// </summary>
        [JsonProperty("ttl")]
        public string Ttl { get; set; }
        /// <summary>
        /// Specifies the maximum Time To Live provided as a string duration with time suffix. Hour is the largest suffix. If not set, defaults to the system maximum lease TTL.
        /// </summary>
        [JsonProperty("max_ttl")]
        public string MaxTtl { get; set; }
        /// <summary>
        /// Specifies a comma-separated list of critical options that certificates can have when signed. To allow any critical options, set this to an empty string. Will default to allowing any critical options.
        /// </summary>
        [JsonProperty("allowed_critical_options")]
        public string AllowedCriticalOptions { get; set; }
        /// <summary>
        /// Specifies a comma-separated list of extensions that certificates can have when signed. To allow a user to specify any extension, set this to "*". If not set, users will not be allowed to specify extensions and will get the extensions specified within default_extensions. For the list of extensions, take a look at the sshd manual's AUTHORIZED_KEYS FILE FORMAT section. You should add a permit- before the name of extension to allow it.
        /// </summary>
        [JsonProperty("allowed_extensions")]
        public string AllowedExtensions { get; set; }
        /// <summary>
        /// Specifies a map of critical options certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by allowed_critical_options. Defaults to none.
        /// </summary>
        [JsonProperty("default_critical_options")]
        public Dictionary<string, string> DefaultCriticalOptions { get; set; }
        /// <summary>
        /// Specifies a map of extensions certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by allowed_extensions. Defaults to none.
        /// </summary>
        [JsonProperty("default_extensions")]
        public Dictionary<string, string> DefaultExtensions { get; set; }
        /// <summary>
        /// Specifies if certificates are allowed to be signed for use as a 'user'.
        /// </summary>
        [JsonProperty("allow_user_certificates")]
        public bool AllowUserCertificates { get; set; } = false;

        /// <summary>
        /// Specifies if certificates are allowed to be signed for use as a 'host'.
        /// </summary>
        [JsonProperty("allow_host_certificates")]
        public bool AllowHostCertificates { get; set; }

        /// <summary>
        /// Specifies if host certificates that are requested are allowed to use the base domains listed in allowed_domains, e.g. "example.com". This is a separate option as in some cases this can be considered a security threat.
        /// </summary>
        [JsonProperty("allow_bare_domains")]
        public bool AllowBareDomains { get; set; } = false;

        /// <summary>
        /// Specifies if host certificates that are requested are allowed to be subdomains of those listed in allowed_domains, e.g. if "example.com" is part of allowed_domains, this allows "foo.example.com".
        /// </summary>
        [JsonProperty("allow_subdomains")]
        public bool AllowSubdomains { get; set; } = false;

        /// <summary>
        /// Specifies if users can override the key ID for a signed certificate with the "key_id" field. When false, the key ID will always be the token display name. The key ID is logged by the SSH server and can be useful for auditing.
        /// </summary>
        [JsonProperty("allow_user_key_ids")]
        public bool AllowUserKeyIds { get; set; } = false;

        /// <summary>
        /// When supplied, this value specifies a custom format for the key id of a signed certificate. The following variables are available for use: '{{token_display_name}}' - The display name of the token used to make the request. '{{role_name}}' - The name of the role signing the request. '{{public_key_hash}}' - A SHA256 checksum of the public key that is being signed. e.g. "custom-keyid-{{token_display_name}}"
        /// </summary>
        [JsonProperty("key_id_format")]
        public string KeyIdFormat { get; set; }

        /// <summary>
        /// Specifies a map of ssh key types and their expected sizes which are allowed to be signed by the CA type. To specify multiple sizes, either use a comma-separated list or an array of allowed key widths. We support both OpenSSH-style key identifiers and short names (rsa, ecdsa, dsa, or ed25519) as keys. For example, a valid policy to allow common RSA and ECDSA key lengths might be:
        /// Note that when an algorithm identifier uniquely specifies a key length (such as with ecdsa-sha2-nistp256 or ed25519), the value of the length is ignored (and can be zero).
        /// </summary>
        [JsonProperty("allowed_user_key_lengths")]
        public Dictionary<string, KeyLength> AllowedUserKeyLengths { get; set; }

        /// <summary>
        /// Algorithm to sign keys with. Valid values are ssh-rsa, rsa-sha2-256, rsa-sha2-512, or default. This value may also be left blank to use the signer's default algorithm, and must be left blank or have value default for CA key types other than RSA.
        /// </summary>
        [JsonProperty("algorithm_signer")]
        public string AlgorithmSigner { get; set; } = "default";

        /// <summary>
        /// Specifies the duration by which to backdate the ValidAfter property. Uses duration format strings.
        /// </summary>
        [JsonProperty("not_before_duration")]
        public string NotBeforeDuration { get; set; } = "30s";

        public SSHRoles()
        {
            KeyBits = 1024;
            AlgorithmSigner = "default";
            NotBeforeDuration = "30s";
        }
    }
}
